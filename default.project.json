{
  "name": "Tatical shooter assets",
  "tree": {
    "$className": "DataModel",
    "ReplicatedStorage": {
      "$path": "src/Shared"
    },
    "ServerScriptService": {
      "$path": "src/Server"
    },
    "StarterPlayer": {
      "StarterCharacter": {
        "$className": "Model",
        "Animate": {
          "$className": "LocalScript",
          "$properties": {
            "Source": "-- humanoidAnimateR15Moods.lua\n\nlocal Character = script.Parent\nlocal Humanoid = Character:WaitForChild(\"Humanoid\")\nlocal pose = \"Standing\"\n\nlocal userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled(\"UserNoUpdateOnLoop\") end)\nlocal userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue\n\nlocal userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled(\"UserAnimateScaleRun\") end)\nlocal userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue\n\nlocal function getRigScale()\n\tif userAnimateScaleRun then\n\t\treturn Character:GetScale()\n\telse\n\t\treturn 1\n\tend\nend\n\nlocal AnimationSpeedDampeningObject = script:FindFirstChild(\"ScaleDampeningPercent\")\nlocal HumanoidHipHeight = 2\n\nlocal EMOTE_TRANSITION_TIME = 0.1\n\nlocal currentAnim = \"\"\nlocal currentAnimInstance = nil\nlocal currentAnimTrack = nil\nlocal currentAnimKeyframeHandler = nil\nlocal currentAnimSpeed = 1.0\n\nlocal runAnimTrack = nil\nlocal runAnimKeyframeHandler = nil\n\nlocal PreloadedAnims = {}\n\nlocal animTable = {}\nlocal animNames = { \n\tidle = \t{\t\n\t\t\t\t\n\t\t\t},\n\twalk = \t{ \t\n\t\t\t\t{ id = \"http://www.roblox.com/asset/?id=507777826\", weight = 10 } \n\t\t\t}, \n\trun = \t{\n\t\t\t\t{ id = \"http://www.roblox.com/asset/?id=507767714\", weight = 10 } \n\t\t\t}, \n\tswim = \t{\n\t\t\t\t{ id = \"http://www.roblox.com/asset/?id=507784897\", weight = 10 } \n\t\t\t}, \n\tswimidle = \t{\n\t\t\t\t{ id = \"http://www.roblox.com/asset/?id=507785072\", weight = 10 } \n\t\t\t}, \n\tjump = \t{\n\t\t\t\t{ id = \"http://www.roblox.com/asset/?id=507765000\", weight = 10 } \n\t\t\t}, \n\tfall = \t{\n\t\t\t\t{ id = \"http://www.roblox.com/asset/?id=507767968\", weight = 10 } \n\t\t\t}, \n\tclimb = {\n\t\t\t\t{ id = \"http://www.roblox.com/asset/?id=507765644\", weight = 10 } \n\t\t\t}, \n\tsit = \t{\n\t\t\t\t{ id = \"http://www.roblox.com/asset/?id=2506281703\", weight = 10 } \n\t\t\t},\t\n\ttoolnone = {\n\t\t\t\t\n\t\t\t},\n\ttoolslash = {\n\t\t\t\t\n\t\t\t},\n\ttoollunge = {\n\t\t\t\t\n\t\t\t},\n\twave = {\n\t\t\t\t\n\t\t\t},\n\tpoint = {\n\t\t\t\t\n\t\t\t},\n\tdance = {\n\t\t\t\t\n\t\t\t},\n\tdance2 = {\n\t\t\t\t \n\t\t\t},\n\tdance3 = {\n\t\t\t\t \n\t\t\t},\n\tlaugh = {\n\t\t\t\t\n\t\t\t},\n\tcheer = {\n\t\t\t\t\n\t\t\t},\n}\n\n-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote\nlocal emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}\n\nmath.randomseed(tick())\n\nfunction findExistingAnimationInSet(set, anim)\n\tif set == nil or anim == nil then\n\t\treturn 0\n\tend\n\t\n\tfor idx = 1, set.count, 1 do \n\t\tif set[idx].anim.AnimationId == anim.AnimationId then\n\t\t\treturn idx\n\t\tend\n\tend\n\t\n\treturn 0\nend\n\nfunction configureAnimationSet(name, fileList)\n\tif (animTable[name] ~= nil) then\n\t\tfor _, connection in pairs(animTable[name].connections) do\n\t\t\tconnection:disconnect()\n\t\tend\n\tend\n\tanimTable[name] = {}\n\tanimTable[name].count = 0\n\tanimTable[name].totalWeight = 0\t\n\tanimTable[name].connections = {}\n\n\tlocal allowCustomAnimations = true\n\n\tlocal success, msg = pcall(function() allowCustomAnimations = game:GetService(\"StarterPlayer\").AllowCustomAnimations end)\n\tif not success then\n\t\tallowCustomAnimations = true\n\tend\n\n\t-- check for config values\n\tlocal config = script:FindFirstChild(name)\n\tif (allowCustomAnimations and config ~= nil) then\n\t\ttable.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))\n\t\ttable.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))\n\t\t\n\t\tlocal idx = 0\n\t\tfor _, childPart in pairs(config:GetChildren()) do\n\t\t\tif (childPart:IsA(\"Animation\")) then\n\t\t\t\tlocal newWeight = 1\n\t\t\t\tlocal weightObject = childPart:FindFirstChild(\"Weight\")\n\t\t\t\tif (weightObject ~= nil) then\n\t\t\t\t\tnewWeight = weightObject.Value\n\t\t\t\tend\n\t\t\t\tanimTable[name].count = animTable[name].count + 1\n\t\t\t\tidx = animTable[name].count\n\t\t\t\tanimTable[name][idx] = {}\n\t\t\t\tanimTable[name][idx].anim = childPart\n\t\t\t\tanimTable[name][idx].weight = newWeight\n\t\t\t\tanimTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight\n\t\t\t\ttable.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))\n\t\t\t\ttable.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))\n\t\t\t\ttable.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))\n\t\t\tend\n\t\tend\n\tend\n\t\n\t-- fallback to defaults\n\tif (animTable[name].count <= 0) then\n\t\tfor idx, anim in pairs(fileList) do\n\t\t\tanimTable[name][idx] = {}\n\t\t\tanimTable[name][idx].anim = Instance.new(\"Animation\")\n\t\t\tanimTable[name][idx].anim.Name = name\n\t\t\tanimTable[name][idx].anim.AnimationId = anim.id\n\t\t\tanimTable[name][idx].weight = anim.weight\n\t\t\tanimTable[name].count = animTable[name].count + 1\n\t\t\tanimTable[name].totalWeight = animTable[name].totalWeight + anim.weight\n\t\tend\n\tend\n\t\n\t-- preload anims\n\tfor i, animType in pairs(animTable) do\n\t\tfor idx = 1, animType.count, 1 do\n\t\t\tif PreloadedAnims[animType[idx].anim.AnimationId] == nil then\n\t\t\t\tHumanoid:LoadAnimation(animType[idx].anim)\n\t\t\t\tPreloadedAnims[animType[idx].anim.AnimationId] = true\n\t\t\tend\t\t\t\t\n\t\tend\n\tend\nend\n\n------------------------------------------------------------------------------------------------------------\n\nfunction configureAnimationSetOld(name, fileList)\n\tif (animTable[name] ~= nil) then\n\t\tfor _, connection in pairs(animTable[name].connections) do\n\t\t\tconnection:disconnect()\n\t\tend\n\tend\n\tanimTable[name] = {}\n\tanimTable[name].count = 0\n\tanimTable[name].totalWeight = 0\t\n\tanimTable[name].connections = {}\n\n\tlocal allowCustomAnimations = true\n\n\tlocal success, msg = pcall(function() allowCustomAnimations = game:GetService(\"StarterPlayer\").AllowCustomAnimations end)\n\tif not success then\n\t\tallowCustomAnimations = true\n\tend\n\n\t-- check for config values\n\tlocal config = script:FindFirstChild(name)\n\tif (allowCustomAnimations and config ~= nil) then\n\t\ttable.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))\n\t\ttable.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))\n\t\tlocal idx = 1\n\t\tfor _, childPart in pairs(config:GetChildren()) do\n\t\t\tif (childPart:IsA(\"Animation\")) then\n\t\t\t\ttable.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))\n\t\t\t\tanimTable[name][idx] = {}\n\t\t\t\tanimTable[name][idx].anim = childPart\n\t\t\t\tlocal weightObject = childPart:FindFirstChild(\"Weight\")\n\t\t\t\tif (weightObject == nil) then\n\t\t\t\t\tanimTable[name][idx].weight = 1\n\t\t\t\telse\n\t\t\t\t\tanimTable[name][idx].weight = weightObject.Value\n\t\t\t\tend\n\t\t\t\tanimTable[name].count = animTable[name].count + 1\n\t\t\t\tanimTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight\n\t\t\t\tidx = idx + 1\n\t\t\tend\n\t\tend\n\tend\n\n\t-- fallback to defaults\n\tif (animTable[name].count <= 0) then\n\t\tfor idx, anim in pairs(fileList) do\n\t\t\tanimTable[name][idx] = {}\n\t\t\tanimTable[name][idx].anim = Instance.new(\"Animation\")\n\t\t\tanimTable[name][idx].anim.Name = name\n\t\t\tanimTable[name][idx].anim.AnimationId = anim.id\n\t\t\tanimTable[name][idx].weight = anim.weight\n\t\t\tanimTable[name].count = animTable[name].count + 1\n\t\t\tanimTable[name].totalWeight = animTable[name].totalWeight + anim.weight\n\t\t\t-- print(name .. \" [\" .. idx .. \"] \" .. anim.id .. \" (\" .. anim.weight .. \")\")\n\t\tend\n\tend\n\t\n\t-- preload anims\n\tfor i, animType in pairs(animTable) do\n\t\tfor idx = 1, animType.count, 1 do \n\t\t\tHumanoid:LoadAnimation(animType[idx].anim)\n\t\tend\n\tend\nend\n\n-- Setup animation objects\nfunction scriptChildModified(child)\n\tlocal fileList = animNames[child.Name]\n\tif (fileList ~= nil) then\n\t\tconfigureAnimationSet(child.Name, fileList)\n\tend\t\nend\n\nscript.ChildAdded:connect(scriptChildModified)\nscript.ChildRemoved:connect(scriptChildModified)\n\n-- Clear any existing animation tracks\n-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks\nlocal animator = if Humanoid then Humanoid:FindFirstChildOfClass(\"Animator\") else nil\nif animator then\n\tlocal animTracks = animator:GetPlayingAnimationTracks()\n\tfor i,track in ipairs(animTracks) do\n\t\ttrack:Stop(0)\n\t\ttrack:Destroy()\n\tend\nend\n\nfor name, fileList in pairs(animNames) do \n\tconfigureAnimationSet(name, fileList)\nend\t\n\n-- ANIMATION\n\n-- declarations\nlocal toolAnim = \"None\"\nlocal toolAnimTime = 0\n\nlocal jumpAnimTime = 0\nlocal jumpAnimDuration = 0.31\n\nlocal toolTransitionTime = 0.1\nlocal fallTransitionTime = 0.2\n\nlocal currentlyPlayingEmote = false\n\n-- functions\n\nfunction stopAllAnimations()\n\tlocal oldAnim = currentAnim\n\n\t-- return to idle if finishing an emote\n\tif (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then\n\t\toldAnim = \"idle\"\n\tend\n\t\n\tif currentlyPlayingEmote then\n\t\toldAnim = \"idle\"\n\t\tcurrentlyPlayingEmote = false\n\tend\n\n\tcurrentAnim = \"\"\n\tcurrentAnimInstance = nil\n\tif (currentAnimKeyframeHandler ~= nil) then\n\t\tcurrentAnimKeyframeHandler:disconnect()\n\tend\n\n\tif (currentAnimTrack ~= nil) then\n\t\tcurrentAnimTrack:Stop()\n\t\tcurrentAnimTrack:Destroy()\n\t\tcurrentAnimTrack = nil\n\tend\n\n\t-- clean up walk if there is one\n\tif (runAnimKeyframeHandler ~= nil) then\n\t\trunAnimKeyframeHandler:disconnect()\n\tend\n\t\n\tif (runAnimTrack ~= nil) then\n\t\trunAnimTrack:Stop()\n\t\trunAnimTrack:Destroy()\n\t\trunAnimTrack = nil\n\tend\n\t\n\treturn oldAnim\nend\n\nfunction getHeightScale()\n\tif Humanoid then\n\t\tif not Humanoid.AutomaticScalingEnabled then\n\t\t\t-- When auto scaling is not enabled, the rig scale stands in for\n\t\t\t-- a computed scale.\n\t\t\treturn getRigScale()\n\t\tend\n\t\t\n\t\tlocal scale = Humanoid.HipHeight / HumanoidHipHeight\n\t\tif AnimationSpeedDampeningObject == nil then\n\t\t\tAnimationSpeedDampeningObject = script:FindFirstChild(\"ScaleDampeningPercent\")\n\t\tend\n\t\tif AnimationSpeedDampeningObject ~= nil then\n\t\t\tscale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight\n\t\tend\n\t\treturn scale\n\tend\t\n\treturn getRigScale()\nend\n\nlocal function rootMotionCompensation(speed)\n\tlocal speedScaled = speed * 1.25\n\tlocal heightScale = getHeightScale()\n\tlocal runSpeed = speedScaled / heightScale\n\treturn runSpeed\nend\n\nlocal smallButNotZero = 0.0001\nlocal function setRunSpeed(speed)\n\tlocal normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation\n\tlocal normalizedRunSpeed  = 1\n\tlocal runSpeed = rootMotionCompensation(speed)\n\n\tlocal walkAnimationWeight = smallButNotZero\n\tlocal runAnimationWeight = smallButNotZero\n\tlocal timeWarp = 1\n\n\tif runSpeed <= normalizedWalkSpeed then\n\t\twalkAnimationWeight = 1\n\t\ttimeWarp = runSpeed/normalizedWalkSpeed\n\telseif runSpeed < normalizedRunSpeed then\n\t\tlocal fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)\n\t\twalkAnimationWeight = 1 - fadeInRun\n\t\trunAnimationWeight  = fadeInRun\n\telse\n\t\ttimeWarp = runSpeed/normalizedRunSpeed\n\t\trunAnimationWeight = 1\n\tend\n\tcurrentAnimTrack:AdjustWeight(walkAnimationWeight)\n\trunAnimTrack:AdjustWeight(runAnimationWeight)\n\tcurrentAnimTrack:AdjustSpeed(timeWarp)\n\trunAnimTrack:AdjustSpeed(timeWarp)\nend\n\nfunction setAnimationSpeed(speed)\n\tif currentAnim == \"walk\" then\n\t\t\tsetRunSpeed(speed)\n\telse\n\t\tif speed ~= currentAnimSpeed then\n\t\t\tcurrentAnimSpeed = speed\n\t\t\tcurrentAnimTrack:AdjustSpeed(currentAnimSpeed)\n\t\tend\n\tend\nend\n\nfunction keyFrameReachedFunc(frameName)\n\tif (frameName == \"End\") then\n\t\tif currentAnim == \"walk\" then\n\t\t\tif userNoUpdateOnLoop == true then\n\t\t\t\tif runAnimTrack.Looped ~= true then\n\t\t\t\t\trunAnimTrack.TimePosition = 0.0\n\t\t\t\tend\n\t\t\t\tif currentAnimTrack.Looped ~= true then\n\t\t\t\t\tcurrentAnimTrack.TimePosition = 0.0\n\t\t\t\tend\n\t\t\telse\n\t\t\t\trunAnimTrack.TimePosition = 0.0\n\t\t\t\tcurrentAnimTrack.TimePosition = 0.0\n\t\t\tend\n\t\telse\n\t\t\tlocal repeatAnim = currentAnim\n\t\t\t-- return to idle if finishing an emote\n\t\t\tif (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then\n\t\t\t\trepeatAnim = \"idle\"\n\t\t\tend\n\t\t\t\n\t\t\tif currentlyPlayingEmote then\n\t\t\t\tif currentAnimTrack.Looped then\n\t\t\t\t\t-- Allow the emote to loop\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\trepeatAnim = \"idle\"\n\t\t\t\tcurrentlyPlayingEmote = false\n\t\t\tend\n\t\t\t\n\t\t\tlocal animSpeed = currentAnimSpeed\n\t\t\tplayAnimation(repeatAnim, 0.15, Humanoid)\n\t\t\tsetAnimationSpeed(animSpeed)\n\t\tend\n\tend\nend\n\nfunction rollAnimation(animName)\n\tlocal roll = math.random(1, animTable[animName].totalWeight) \n\tlocal origRoll = roll\n\tlocal idx = 1\n\twhile (roll > animTable[animName][idx].weight) do\n\t\troll = roll - animTable[animName][idx].weight\n\t\tidx = idx + 1\n\tend\n\treturn idx\nend\n\nlocal function switchToAnim(anim, animName, transitionTime, humanoid)\n\t-- switch animation\t\t\n\tif (anim ~= currentAnimInstance) then\n\t\t\n\t\tif (currentAnimTrack ~= nil) then\n\t\t\tcurrentAnimTrack:Stop(transitionTime)\n\t\t\tcurrentAnimTrack:Destroy()\n\t\tend\n\n\t\tif (runAnimTrack ~= nil) then\n\t\t\trunAnimTrack:Stop(transitionTime)\n\t\t\trunAnimTrack:Destroy()\n\t\t\tif userNoUpdateOnLoop == true then\n\t\t\t\trunAnimTrack = nil\n\t\t\tend\n\t\tend\n\n\t\tcurrentAnimSpeed = 1.0\n\t\n\t\t-- load it to the humanoid; get AnimationTrack\n\t\tcurrentAnimTrack = humanoid:LoadAnimation(anim)\n\t\tcurrentAnimTrack.Priority = Enum.AnimationPriority.Core\n\t\t \n\t\t-- play the animation\n\t\tcurrentAnimTrack:Play(transitionTime)\n\t\tcurrentAnim = animName\n\t\tcurrentAnimInstance = anim\n\n\t\t-- set up keyframe name triggers\n\t\tif (currentAnimKeyframeHandler ~= nil) then\n\t\t\tcurrentAnimKeyframeHandler:disconnect()\n\t\tend\n\t\tcurrentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)\n\t\t\n\t\t-- check to see if we need to blend a walk/run animation\n\t\tif animName == \"walk\" then\n\t\t\tlocal runAnimName = \"run\"\n\t\t\tlocal runIdx = rollAnimation(runAnimName)\n\n\t\t\trunAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)\n\t\t\trunAnimTrack.Priority = Enum.AnimationPriority.Core\n\t\t\trunAnimTrack:Play(transitionTime)\t\t\n\t\t\t\n\t\t\tif (runAnimKeyframeHandler ~= nil) then\n\t\t\t\trunAnimKeyframeHandler:disconnect()\n\t\t\tend\n\t\t\trunAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)\t\n\t\tend\n\tend\nend\n\nfunction playAnimation(animName, transitionTime, humanoid) \t\n\tlocal idx = rollAnimation(animName)\n\tlocal anim = animTable[animName][idx].anim\n\n\tswitchToAnim(anim, animName, transitionTime, humanoid)\n\tcurrentlyPlayingEmote = false\nend\n\nfunction playEmote(emoteAnim, transitionTime, humanoid)\n\tswitchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)\n\tcurrentlyPlayingEmote = true\nend\n\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\n\nlocal toolAnimName = \"\"\nlocal toolAnimTrack = nil\nlocal toolAnimInstance = nil\nlocal currentToolAnimKeyframeHandler = nil\n\nfunction toolKeyFrameReachedFunc(frameName)\n\tif (frameName == \"End\") then\n\t\tplayToolAnimation(toolAnimName, 0.0, Humanoid)\n\tend\nend\n\n\nfunction playToolAnimation(animName, transitionTime, humanoid, priority)\t \t\t\n\t\tlocal idx = rollAnimation(animName)\n\t\tlocal anim = animTable[animName][idx].anim\n\n\t\tif (toolAnimInstance ~= anim) then\n\t\t\t\n\t\t\tif (toolAnimTrack ~= nil) then\n\t\t\t\ttoolAnimTrack:Stop()\n\t\t\t\ttoolAnimTrack:Destroy()\n\t\t\t\ttransitionTime = 0\n\t\t\tend\n\t\t\t\t\t\n\t\t\t-- load it to the humanoid; get AnimationTrack\n\t\t\ttoolAnimTrack = humanoid:LoadAnimation(anim)\n\t\t\tif priority then\n\t\t\t\ttoolAnimTrack.Priority = priority\n\t\t\tend\n\t\t\t \n\t\t\t-- play the animation\n\t\t\ttoolAnimTrack:Play(transitionTime)\n\t\t\ttoolAnimName = animName\n\t\t\ttoolAnimInstance = anim\n\n\t\t\tcurrentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)\n\t\tend\nend\n\nfunction stopToolAnimations()\n\tlocal oldAnim = toolAnimName\n\n\tif (currentToolAnimKeyframeHandler ~= nil) then\n\t\tcurrentToolAnimKeyframeHandler:disconnect()\n\tend\n\n\ttoolAnimName = \"\"\n\ttoolAnimInstance = nil\n\tif (toolAnimTrack ~= nil) then\n\t\ttoolAnimTrack:Stop()\n\t\ttoolAnimTrack:Destroy()\n\t\ttoolAnimTrack = nil\n\tend\n\n\treturn oldAnim\nend\n\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\n-- STATE CHANGE HANDLERS\n\nfunction onRunning(speed)\n\tlocal heightScale = if userAnimateScaleRun then getHeightScale() else 1\n\t\n\tlocal movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)\n\tlocal speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75\n\tif speed > speedThreshold * heightScale then\n\t\tlocal scale = 16.0\n\t\tplayAnimation(\"walk\", 0.2, Humanoid)\n\t\tsetAnimationSpeed(speed / scale)\n\t\tpose = \"Running\"\n\telse\n\t\tif emoteNames[currentAnim] == nil and not currentlyPlayingEmote then\n\t\t\t--playAnimation(\"idle\", 0.2, Humanoid)\n\t\t\tpose = \"Standing\"\n\t\tend\n\tend\nend\n\nfunction onDied()\n\tpose = \"Dead\"\nend\n\nfunction onJumping()\n\tplayAnimation(\"jump\", 0.1, Humanoid)\n\tjumpAnimTime = jumpAnimDuration\n\tpose = \"Jumping\"\nend\n\nfunction onClimbing(speed)\n\tif userAnimateScaleRun then\n\t\tspeed /= getHeightScale()\n\tend\n\tlocal scale = 5.0\n\tplayAnimation(\"climb\", 0.1, Humanoid)\n\tsetAnimationSpeed(speed / scale)\n\tpose = \"Climbing\"\nend\n\nfunction onGettingUp()\n\tpose = \"GettingUp\"\nend\n\nfunction onFreeFall()\n\tif (jumpAnimTime <= 0) then\n\t\tplayAnimation(\"fall\", fallTransitionTime, Humanoid)\n\tend\n\tpose = \"FreeFall\"\nend\n\nfunction onFallingDown()\n\tpose = \"FallingDown\"\nend\n\nfunction onSeated()\n\tpose = \"Seated\"\nend\n\nfunction onPlatformStanding()\n\tpose = \"PlatformStanding\"\nend\n\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\n\nfunction onSwimming(speed)\n\tif userAnimateScaleRun then\n\t\tspeed /= getHeightScale()\n\tend\n\tif speed > 1.00 then\n\t\tlocal scale = 10.0\n\t\tplayAnimation(\"swim\", 0.4, Humanoid)\n\t\tsetAnimationSpeed(speed / scale)\n\t\tpose = \"Swimming\"\n\telse\n\t\tplayAnimation(\"swimidle\", 0.4, Humanoid)\n\t\tpose = \"Standing\"\n\tend\nend\n\nfunction animateTool()\n\tif (toolAnim == \"None\") then\n\t\tplayToolAnimation(\"toolnone\", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)\n\t\treturn\n\tend\n\n\tif (toolAnim == \"Slash\") then\n\t\tplayToolAnimation(\"toolslash\", 0, Humanoid, Enum.AnimationPriority.Action)\n\t\treturn\n\tend\n\n\tif (toolAnim == \"Lunge\") then\n\t\tplayToolAnimation(\"toollunge\", 0, Humanoid, Enum.AnimationPriority.Action)\n\t\treturn\n\tend\nend\n\nfunction getToolAnim(tool)\n\tfor _, c in ipairs(tool:GetChildren()) do\n\t\tif c.Name == \"toolanim\" and c.className == \"StringValue\" then\n\t\t\treturn c\n\t\tend\n\tend\n\treturn nil\nend\n\nlocal lastTick = 0\n\nfunction stepAnimate(currentTime)\n\tlocal amplitude = 1\n\tlocal frequency = 1\n  \tlocal deltaTime = currentTime - lastTick\n  \tlastTick = currentTime\n\n\tlocal climbFudge = 0\n\tlocal setAngles = false\n\n  \tif (jumpAnimTime > 0) then\n  \t\tjumpAnimTime = jumpAnimTime - deltaTime\n  \tend\n\n\tif (pose == \"FreeFall\" and jumpAnimTime <= 0) then\n\t\tplayAnimation(\"fall\", fallTransitionTime, Humanoid)\n\telseif (pose == \"Seated\") then\n\t\tplayAnimation(\"sit\", 0.5, Humanoid)\n\t\treturn\n\telseif (pose == \"Running\") then\n\t\tplayAnimation(\"walk\", 0.2, Humanoid)\n\telseif (pose == \"Dead\" or pose == \"GettingUp\" or pose == \"FallingDown\" or pose == \"Seated\" or pose == \"PlatformStanding\") then\n\t\tstopAllAnimations()\n\t\tamplitude = 0.1\n\t\tfrequency = 1\n\t\tsetAngles = true\n\tend\n\n\t-- Tool Animation handling\n\tlocal tool = Character:FindFirstChildOfClass(\"Tool\")\n\tif tool and tool:FindFirstChild(\"Handle\") then\n\t\tlocal animStringValueObject = getToolAnim(tool)\n\n\t\tif animStringValueObject then\n\t\t\ttoolAnim = animStringValueObject.Value\n\t\t\t-- message recieved, delete StringValue\n\t\t\tanimStringValueObject.Parent = nil\n\t\t\ttoolAnimTime = currentTime + .3\n\t\tend\n\n\t\tif currentTime > toolAnimTime then\n\t\t\ttoolAnimTime = 0\n\t\t\ttoolAnim = \"None\"\n\t\tend\n\n\t\tanimateTool()\t\t\n\telse\n\t\tstopToolAnimations()\n\t\ttoolAnim = \"None\"\n\t\ttoolAnimInstance = nil\n\t\ttoolAnimTime = 0\n\tend\nend\n\n-- connect events\nHumanoid.Died:connect(onDied)\nHumanoid.Running:connect(onRunning)\nHumanoid.Jumping:connect(onJumping)\nHumanoid.Climbing:connect(onClimbing)\nHumanoid.GettingUp:connect(onGettingUp)\nHumanoid.FreeFalling:connect(onFreeFall)\nHumanoid.FallingDown:connect(onFallingDown)\nHumanoid.Seated:connect(onSeated)\nHumanoid.PlatformStanding:connect(onPlatformStanding)\nHumanoid.Swimming:connect(onSwimming)\n\n-- setup emote chat hook\ngame:GetService(\"Players\").LocalPlayer.Chatted:connect(function(msg)\n\tlocal emote = \"\"\n\tif (string.sub(msg, 1, 3) == \"/e \") then\n\t\temote = string.sub(msg, 4)\n\telseif (string.sub(msg, 1, 7) == \"/emote \") then\n\t\temote = string.sub(msg, 8)\n\tend\n\t\n\tif (pose == \"Standing\" and emoteNames[emote] ~= nil) then\n\t\tplayAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)\n\tend\nend)\n\n-- emote bindable hook\nscript:WaitForChild(\"PlayEmote\").OnInvoke = function(emote)\n\t-- Only play emotes when idling\n\tif pose ~= \"Standing\" then\n\t\treturn\n\tend\n\n\tif emoteNames[emote] ~= nil then\n\t\t-- Default emotes\n\t\tplayAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)\n\t\t\n\t\treturn true, currentAnimTrack\n\telseif typeof(emote) == \"Instance\" and emote:IsA(\"Animation\") then\n\t\t-- Non-default emotes\n\t\tplayEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)\n\n\t\treturn true, currentAnimTrack\n\tend\n\t\n\t-- Return false to indicate that the emote could not be played\n\treturn false\nend\n\nif Character.Parent ~= nil then\n\t-- initialize to idle\n\t--playAnimation(\"idle\", 0.1, Humanoid)\n\tpose = \"Standing\"\nend\n\n-- loop to handle timed state transitions and tool animations\nwhile Character.Parent ~= nil do\n\tlocal _, currentGameTime = wait(0.1)\n\tstepAnimate(currentGameTime)\nend\n\n"
          }
        }
      },
      "StarterPlayerScripts": {
        "$path": "src/Client"
      },
      "$properties": {
        "CharacterMaxSlopeAngle": 60,
        "CharacterUseJumpPower": false,
        "CameraMaxZoomDistance": 128
      }
    }
  }
}
